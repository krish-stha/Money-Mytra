"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterable
from typing import overload
from google.generativeai import caching, protos
from google.generativeai.types import content_types, generation_types, helper_types, safety_types

"""
This type stub file was generated by pyright.
"""
_USER_ROLE = ...
_MODEL_ROLE = ...
class GenerativeModel:
    """
    The `genai.GenerativeModel` class wraps default parameters for calls to
    `GenerativeModel.generate_content`, `GenerativeModel.count_tokens`, and
    `GenerativeModel.start_chat`.

    This family of functionality is designed to support multi-turn conversations, and multimodal
    requests. What media-types are supported for input and output is model-dependant.

    >>> import google.generativeai as genai
    >>> import PIL.Image
    >>> genai.configure(api_key='YOUR_API_KEY')
    >>> model = genai.GenerativeModel('models/gemini-pro')
    >>> result = model.generate_content('Tell me a story about a magic backpack')
    >>> result.text
    "In the quaint little town of Lakeside, there lived a young girl named Lily..."

    Multimodal input:

    >>> model = genai.GenerativeModel('models/gemini-pro')
    >>> result = model.generate_content([
    ...     "Give me a recipe for these:", PIL.Image.open('scones.jpeg')])
    >>> result.text
    "**Blueberry Scones** ..."

    Multi-turn conversation:

    >>> chat = model.start_chat()
    >>> response = chat.send_message("Hi, I have some questions for you.")
    >>> response.text
    "Sure, I'll do my best to answer your questions..."

    To list the compatible model names use:

    >>> for m in genai.list_models():
    ...     if 'generateContent' in m.supported_generation_methods:
    ...         print(m.name)

    Arguments:
         model_name: The name of the model to query. To list compatible models use
         safety_settings: Sets the default safety filters. This controls which content is blocked
             by the api before being returned.
         generation_config: A `genai.GenerationConfig` setting the default generation parameters to
             use.
    """
    def __init__(self, model_name: str = ..., safety_settings: safety_types.SafetySettingOptions | None = ..., generation_config: generation_types.GenerationConfigType | None = ..., tools: content_types.FunctionLibraryType | None = ..., tool_config: content_types.ToolConfigType | None = ..., system_instruction: content_types.ContentType | None = ...) -> None:
        ...
    
    @property
    def cached_content(self) -> str:
        ...
    
    @property
    def model_name(self):
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...
    @overload
    @classmethod
    def from_cached_content(cls, cached_content: str, *, generation_config: generation_types.GenerationConfigType | None = ..., safety_settings: safety_types.SafetySettingOptions | None = ...) -> GenerativeModel:
        ...
    
    @overload
    @classmethod
    def from_cached_content(cls, cached_content: caching.CachedContent, *, generation_config: generation_types.GenerationConfigType | None = ..., safety_settings: safety_types.SafetySettingOptions | None = ...) -> GenerativeModel:
        ...
    
    @classmethod
    def from_cached_content(cls, cached_content: str | caching.CachedContent, *, generation_config: generation_types.GenerationConfigType | None = ..., safety_settings: safety_types.SafetySettingOptions | None = ...) -> GenerativeModel:
        """Creates a model with `cached_content` as model's context.

        Args:
            cached_content: context for the model.
            generation_config: Overrides for the model's generation config.
            safety_settings: Overrides for the model's safety settings.

        Returns:
            `GenerativeModel` object with `cached_content` as its context.
        """
        ...
    
    def generate_content(self, contents: content_types.ContentsType, *, generation_config: generation_types.GenerationConfigType | None = ..., safety_settings: safety_types.SafetySettingOptions | None = ..., stream: bool = ..., tools: content_types.FunctionLibraryType | None = ..., tool_config: content_types.ToolConfigType | None = ..., request_options: helper_types.RequestOptionsType | None = ...) -> generation_types.GenerateContentResponse:
        """A multipurpose function to generate responses from the model.

        This `GenerativeModel.generate_content` method can handle multimodal input, and multi-turn
        conversations.

        >>> model = genai.GenerativeModel('models/gemini-pro')
        >>> response = model.generate_content('Tell me a story about a magic backpack')
        >>> response.text

        ### Streaming

        This method supports streaming with the `stream=True`. The result has the same type as the non streaming case,
        but you can iterate over the response chunks as they become available:

        >>> response = model.generate_content('Tell me a story about a magic backpack', stream=True)
        >>> for chunk in response:
        ...   print(chunk.text)

        ### Multi-turn

        This method supports multi-turn chats but is **stateless**: the entire conversation history needs to be sent with each
        request. This takes some manual management but gives you complete control:

        >>> messages = [{'role':'user', 'parts': ['hello']}]
        >>> response = model.generate_content(messages) # "Hello, how can I help"
        >>> messages.append(response.candidates[0].content)
        >>> messages.append({'role':'user', 'parts': ['How does quantum physics work?']})
        >>> response = model.generate_content(messages)

        For a simpler multi-turn interface see `GenerativeModel.start_chat`.

        ### Input type flexibility

        While the underlying API strictly expects a `list[protos.Content]` objects, this method
        will convert the user input into the correct type. The hierarchy of types that can be
        converted is below. Any of these objects can be passed as an equivalent `dict`.

        * `Iterable[protos.Content]`
        * `protos.Content`
        * `Iterable[protos.Part]`
        * `protos.Part`
        * `str`, `Image`, or `protos.Blob`

        In an `Iterable[protos.Content]` each `content` is a separate message.
        But note that an `Iterable[protos.Part]` is taken as the parts of a single message.

        Arguments:
            contents: The contents serving as the model's prompt.
            generation_config: Overrides for the model's generation config.
            safety_settings: Overrides for the model's safety settings.
            stream: If True, yield response chunks as they are generated.
            tools: `protos.Tools` more info coming soon.
            request_options: Options for the request.
        """
        ...
    
    async def generate_content_async(self, contents: content_types.ContentsType, *, generation_config: generation_types.GenerationConfigType | None = ..., safety_settings: safety_types.SafetySettingOptions | None = ..., stream: bool = ..., tools: content_types.FunctionLibraryType | None = ..., tool_config: content_types.ToolConfigType | None = ..., request_options: helper_types.RequestOptionsType | None = ...) -> generation_types.AsyncGenerateContentResponse:
        """The async version of `GenerativeModel.generate_content`."""
        ...
    
    def count_tokens(self, contents: content_types.ContentsType = ..., *, generation_config: generation_types.GenerationConfigType | None = ..., safety_settings: safety_types.SafetySettingOptions | None = ..., tools: content_types.FunctionLibraryType | None = ..., tool_config: content_types.ToolConfigType | None = ..., request_options: helper_types.RequestOptionsType | None = ...) -> protos.CountTokensResponse:
        ...
    
    async def count_tokens_async(self, contents: content_types.ContentsType = ..., *, generation_config: generation_types.GenerationConfigType | None = ..., safety_settings: safety_types.SafetySettingOptions | None = ..., tools: content_types.FunctionLibraryType | None = ..., tool_config: content_types.ToolConfigType | None = ..., request_options: helper_types.RequestOptionsType | None = ...) -> protos.CountTokensResponse:
        ...
    
    def start_chat(self, *, history: Iterable[content_types.StrictContentType] | None = ..., enable_automatic_function_calling: bool = ...) -> ChatSession:
        """Returns a `genai.ChatSession` attached to this model.

        >>> model = genai.GenerativeModel()
        >>> chat = model.start_chat(history=[...])
        >>> response = chat.send_message("Hello?")

        Arguments:
            history: An iterable of `protos.Content` objects, or equivalents to initialize the session.
        """
        ...
    


class ChatSession:
    """Contains an ongoing conversation with the model.

    >>> model = genai.GenerativeModel('models/gemini-pro')
    >>> chat = model.start_chat()
    >>> response = chat.send_message("Hello")
    >>> print(response.text)
    >>> response = chat.send_message("Hello again")
    >>> print(response.text)
    >>> response = chat.send_message(...

    This `ChatSession` object collects the messages sent and received, in its
    `ChatSession.history` attribute.

    Arguments:
        model: The model to use in the chat.
        history: A chat history to initialize the object with.
    """
    def __init__(self, model: GenerativeModel, history: Iterable[content_types.StrictContentType] | None = ..., enable_automatic_function_calling: bool = ...) -> None:
        ...
    
    def send_message(self, content: content_types.ContentType, *, generation_config: generation_types.GenerationConfigType = ..., safety_settings: safety_types.SafetySettingOptions = ..., stream: bool = ..., tools: content_types.FunctionLibraryType | None = ..., tool_config: content_types.ToolConfigType | None = ..., request_options: helper_types.RequestOptionsType | None = ...) -> generation_types.GenerateContentResponse:
        """Sends the conversation history with the added message and returns the model's response.

        Appends the request and response to the conversation history.

        >>> model = genai.GenerativeModel('models/gemini-pro')
        >>> chat = model.start_chat()
        >>> response = chat.send_message("Hello")
        >>> print(response.text)
        "Hello! How can I assist you today?"
        >>> len(chat.history)
        2

        Call it with `stream=True` to receive response chunks as they are generated:

        >>> chat = model.start_chat()
        >>> response = chat.send_message("Explain quantum physics", stream=True)
        >>> for chunk in response:
        ...   print(chunk.text, end='')

        Once iteration over chunks is complete, the `response` and `ChatSession` are in states identical to the
        `stream=False` case. Some properties are not available until iteration is complete.

        Like `GenerativeModel.generate_content` this method lets you override the model's `generation_config` and
        `safety_settings`.

        Arguments:
             content: The message contents.
             generation_config: Overrides for the model's generation config.
             safety_settings: Overrides for the model's safety settings.
             stream: If True, yield response chunks as they are generated.
        """
        ...
    
    async def send_message_async(self, content: content_types.ContentType, *, generation_config: generation_types.GenerationConfigType = ..., safety_settings: safety_types.SafetySettingOptions = ..., stream: bool = ..., tools: content_types.FunctionLibraryType | None = ..., tool_config: content_types.ToolConfigType | None = ..., request_options: helper_types.RequestOptionsType | None = ...) -> generation_types.AsyncGenerateContentResponse:
        """The async version of `ChatSession.send_message`."""
        ...
    
    def __copy__(self):
        ...
    
    def rewind(self) -> tuple[protos.Content, protos.Content]:
        """Removes the last request/response pair from the chat history."""
        ...
    
    @property
    def last(self) -> generation_types.BaseGenerateContentResponse | None:
        """returns the last received `genai.GenerateContentResponse`"""
        ...
    
    @property
    def history(self) -> list[protos.Content]:
        """The chat history."""
        ...
    
    @history.setter
    def history(self, history):
        ...
    
    def __repr__(self) -> str:
        ...
    


