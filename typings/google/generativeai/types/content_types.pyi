"""
This type stub file was generated by pyright.
"""

import typing
import PIL.Image
import IPython.display
from collections.abc import Iterable
from typing import Any, Callable, Union
from typing_extensions import TypedDict
from google.generativeai.types import file_types
from google.generativeai import protos

"""
This type stub file was generated by pyright.
"""
if typing.TYPE_CHECKING:
    IMAGE_TYPES = ...
else:
    ...
__all__ = ["BlobDict", "BlobType", "PartDict", "PartType", "ContentDict", "ContentType", "StrictContentType", "ContentsType", "FunctionDeclaration", "CallableFunctionDeclaration", "FunctionDeclarationType", "Tool", "ToolDict", "ToolsType", "FunctionLibrary", "FunctionLibraryType"]
Mode = protos.DynamicRetrievalConfig.Mode
ModeOptions = Union[int, str, Mode]
_MODE: dict[ModeOptions, Mode] = ...
def to_mode(x: ModeOptions) -> Mode:
    ...

def image_to_blob(image) -> protos.Blob:
    ...

class BlobDict(TypedDict):
    mime_type: str
    data: bytes
    ...


def is_blob_dict(d):
    ...

if typing.TYPE_CHECKING:
    BlobType = Union[protos.Blob, BlobDict, PIL.Image.Image, IPython.display.Image]
else:
    ...
def to_blob(blob: BlobType) -> protos.Blob:
    ...

class PartDict(TypedDict):
    text: str
    inline_data: BlobType
    ...


PartType = Union[protos.Part, PartDict, BlobType, str, protos.FunctionCall, protos.FunctionResponse, file_types.FileDataType,]
def is_part_dict(d):
    ...

def to_part(part: PartType):
    ...

class ContentDict(TypedDict):
    parts: list[PartType]
    role: str
    ...


def is_content_dict(d):
    ...

ContentType = Union[protos.Content, ContentDict, Iterable[PartType], PartType]
StrictContentType = Union[protos.Content, ContentDict]
def to_content(content: ContentType):
    ...

def strict_to_content(content: StrictContentType):
    ...

ContentsType = Union[ContentType, Iterable[StrictContentType], None]
def to_contents(contents: ContentsType) -> list[protos.Content]:
    ...

def unpack_defs(schema, defs):
    ...

def strip_titles(schema):
    ...

def add_object_type(schema):
    ...

def convert_to_nullable(schema):
    ...

class FunctionDeclaration:
    def __init__(self, *, name: str, description: str, parameters: dict[str, Any] | None = ...) -> None:
        """A  class wrapping a `protos.FunctionDeclaration`, describes a function for `genai.GenerativeModel`'s `tools`."""
        ...
    
    @property
    def name(self) -> str:
        ...
    
    @property
    def description(self) -> str:
        ...
    
    @property
    def parameters(self) -> protos.Schema:
        ...
    
    @classmethod
    def from_proto(cls, proto) -> FunctionDeclaration:
        ...
    
    def to_proto(self) -> protos.FunctionDeclaration:
        ...
    
    @staticmethod
    def from_function(function: Callable[..., Any], descriptions: dict[str, str] | None = ...):
        """Builds a `CallableFunctionDeclaration` from a python function.

        The function should have type annotations.

        This method is able to generate the schema for arguments annotated with types:

        `AllowedTypes = float | int | str | list[AllowedTypes] | dict`

        This method does not yet build a schema for `TypedDict`, that would allow you to specify the dictionary
        contents. But you can build these manually.
        """
        ...
    


StructType = dict[str, "ValueType"]
ValueType = Union[float, str, bool, StructType, list["ValueType"], None]
class CallableFunctionDeclaration(FunctionDeclaration):
    """An extension of `FunctionDeclaration` that can be built from a python function, and is callable.

    Note: The python function must have type annotations.
    """
    def __init__(self, *, name: str, description: str, parameters: dict[str, Any] | None = ..., function: Callable[..., Any]) -> None:
        ...
    
    def __call__(self, fc: protos.FunctionCall) -> protos.FunctionResponse:
        ...
    


FunctionDeclarationType = Union[FunctionDeclaration, protos.FunctionDeclaration, dict[str, Any], Callable[..., Any],]
class DynamicRetrievalConfigDict(TypedDict):
    mode: protos.DynamicRetrievalConfig.mode
    dynamic_threshold: float
    ...


DynamicRetrievalConfig = Union[protos.DynamicRetrievalConfig, DynamicRetrievalConfigDict]
class GoogleSearchRetrievalDict(TypedDict):
    dynamic_retrieval_config: DynamicRetrievalConfig
    ...


GoogleSearchRetrievalType = Union[protos.GoogleSearchRetrieval, GoogleSearchRetrievalDict]
class Tool:
    """A wrapper for `protos.Tool`, Contains a collection of related `FunctionDeclaration` objects,
    protos.CodeExecution object, and protos.GoogleSearchRetrieval object."""
    def __init__(self, *, function_declarations: Iterable[FunctionDeclarationType] | None = ..., google_search_retrieval: GoogleSearchRetrievalType | None = ..., code_execution: protos.CodeExecution | None = ...) -> None:
        ...
    
    @property
    def function_declarations(self) -> list[FunctionDeclaration | protos.FunctionDeclaration]:
        ...
    
    @property
    def google_search_retrieval(self) -> protos.GoogleSearchRetrieval:
        ...
    
    @property
    def code_execution(self) -> protos.CodeExecution:
        ...
    
    def __getitem__(self, name: str | protos.FunctionCall) -> FunctionDeclaration | protos.FunctionDeclaration:
        ...
    
    def __call__(self, fc: protos.FunctionCall) -> protos.FunctionResponse | None:
        ...
    
    def to_proto(self):
        ...
    


class ToolDict(TypedDict):
    function_declarations: list[FunctionDeclarationType]
    ...


ToolType = Union[str, Tool, protos.Tool, ToolDict, Iterable[FunctionDeclarationType], FunctionDeclarationType]
class FunctionLibrary:
    """A container for a set of `Tool` objects, manages lookup and execution of their functions."""
    def __init__(self, tools: Iterable[ToolType]) -> None:
        ...
    
    def __getitem__(self, name: str | protos.FunctionCall) -> FunctionDeclaration | protos.FunctionDeclaration:
        ...
    
    def __call__(self, fc: protos.FunctionCall) -> protos.Part | None:
        ...
    
    def to_proto(self):
        ...
    


ToolsType = Union[Iterable[ToolType], ToolType]
FunctionLibraryType = Union[FunctionLibrary, ToolsType]
def to_function_library(lib: FunctionLibraryType | None) -> FunctionLibrary | None:
    ...

FunctionCallingMode = protos.FunctionCallingConfig.Mode
_FUNCTION_CALLING_MODE = ...
FunctionCallingModeType = Union[FunctionCallingMode, str, int]
def to_function_calling_mode(x: FunctionCallingModeType) -> FunctionCallingMode:
    ...

class FunctionCallingConfigDict(TypedDict):
    mode: FunctionCallingModeType
    allowed_function_names: list[str]
    ...


FunctionCallingConfigType = Union[FunctionCallingModeType, FunctionCallingConfigDict, protos.FunctionCallingConfig]
def to_function_calling_config(obj: FunctionCallingConfigType) -> protos.FunctionCallingConfig:
    ...

class ToolConfigDict:
    function_calling_config: FunctionCallingConfigType
    ...


ToolConfigType = Union[ToolConfigDict, protos.ToolConfig]
def to_tool_config(obj: ToolConfigType) -> protos.ToolConfig:
    ...

