"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterable
from typing import Any, Callable, Union
from typing_extensions import TypedDict
from google.generativeai import protos

"""
This type stub file was generated by pyright.
"""
Type = protos.Type
TypeOptions = Union[int, str, Type]
_TYPE_TYPE: dict[TypeOptions, Type] = ...
def to_type(x: TypeOptions) -> Type:
    ...

class FunctionDeclaration:
    def __init__(self, *, name: str, description: str, parameters: dict[str, Any] | None = ...) -> None:
        """A  class wrapping a `protos.FunctionDeclaration`, describes a function for `genai.GenerativeModel`'s `tools`."""
        ...
    
    @property
    def name(self) -> str:
        ...
    
    @property
    def description(self) -> str:
        ...
    
    @property
    def parameters(self) -> protos.Schema:
        ...
    
    @classmethod
    def from_proto(cls, proto) -> FunctionDeclaration:
        ...
    
    def to_proto(self) -> protos.FunctionDeclaration:
        ...
    
    @staticmethod
    def from_function(function: Callable[..., Any], descriptions: dict[str, str] | None = ...):
        """Builds a `CallableFunctionDeclaration` from a python function.

        The function should have type annotations.

        This method is able to generate the schema for arguments annotated with types:

        `AllowedTypes = float | int | str | list[AllowedTypes] | dict`

        This method does not yet build a schema for `TypedDict`, that would allow you to specify the dictionary
        contents. But you can build these manually.
        """
        ...
    


StructType = dict[str, "ValueType"]
ValueType = Union[float, str, bool, StructType, list["ValueType"], None]
class CallableFunctionDeclaration(FunctionDeclaration):
    """An extension of `FunctionDeclaration` that can be built from a Python function, and is callable.

    Note: The Python function must have type annotations.
    """
    def __init__(self, *, name: str, description: str, parameters: dict[str, Any] | None = ..., function: Callable[..., Any]) -> None:
        ...
    
    def __call__(self, fc: protos.FunctionCall) -> protos.FunctionResponse:
        ...
    


FunctionDeclarationType = Union[FunctionDeclaration, protos.FunctionDeclaration, dict[str, Any], Callable[..., Any],]
class Tool:
    """A wrapper for `protos.Tool`, Contains a collection of related `FunctionDeclaration` objects."""
    def __init__(self, function_declarations: Iterable[FunctionDeclarationType]) -> None:
        ...
    
    @property
    def function_declarations(self) -> list[FunctionDeclaration | protos.FunctionDeclaration]:
        ...
    
    def __getitem__(self, name: str | protos.FunctionCall) -> FunctionDeclaration | protos.FunctionDeclaration:
        ...
    
    def __call__(self, fc: protos.FunctionCall) -> protos.FunctionResponse | None:
        ...
    
    def to_proto(self):
        ...
    


class ToolDict(TypedDict):
    function_declarations: list[FunctionDeclarationType]
    ...


ToolType = Union[Tool, protos.Tool, ToolDict, Iterable[FunctionDeclarationType], FunctionDeclarationType]
class FunctionLibrary:
    """A container for a set of `Tool` objects, manages lookup and execution of their functions."""
    def __init__(self, tools: Iterable[ToolType]) -> None:
        ...
    
    def __getitem__(self, name: str | protos.FunctionCall) -> FunctionDeclaration | protos.FunctionDeclaration:
        ...
    
    def __call__(self, fc: protos.FunctionCall) -> protos.Part | None:
        ...
    
    def to_proto(self):
        ...
    


ToolsType = Union[Iterable[ToolType], ToolType]
FunctionLibraryType = Union[FunctionLibrary, ToolsType]
def to_function_library(lib: FunctionLibraryType | None) -> FunctionLibrary | None:
    ...

FunctionCallingMode = protos.FunctionCallingConfig.Mode
_FUNCTION_CALLING_MODE = ...
FunctionCallingModeType = Union[FunctionCallingMode, str, int]
def to_function_calling_mode(x: FunctionCallingModeType) -> FunctionCallingMode:
    ...

class FunctionCallingConfigDict(TypedDict):
    mode: FunctionCallingModeType
    allowed_function_names: list[str]
    ...


FunctionCallingConfigType = Union[FunctionCallingModeType, FunctionCallingConfigDict, protos.FunctionCallingConfig]
def to_function_calling_config(obj: FunctionCallingConfigType) -> protos.FunctionCallingConfig:
    ...

class ToolConfigDict:
    function_calling_config: FunctionCallingConfigType
    ...


ToolConfigType = Union[ToolConfigDict, protos.ToolConfig]
def to_tool_config(obj: ToolConfigType) -> protos.ToolConfig:
    ...

